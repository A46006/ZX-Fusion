#include "file_format_aux.h"
#include "asm_opcodes.h"
#include "mem_addrs.h"

alt_u16 conv_data_8_16(alt_u8* data, int offset) {
	return ((data[offset] << 8) & 0xFF00) | (data[offset+1]);
}

int get_routine_size_SNA() {
	return 53;
}

int get_routine_size_z80() {
	return 54;
}

//////////////////////////////////////
// Gonna change method of loading regs
// Using the stack!
// Must generate data to write to stack area
// based on routine order:
//
// SP is decremented for each push
//
// For TAP, SP has PC in it already, so must make that distinction
//
// Skip this step for TAP files: SP--; PC&0xFF00 >> 8; SP--; PC&0xFF
//
// Since Interrupt mode and EI/DI must be saved, this will come in 1 byte:
//          7  6  5  4  3  2  1  0
//         EI             IM IM IM
// Occupying IM with 3 bits instead of 2 so a simple BIT check can be done
// instead of arithmetic. Also I have extra space
//
// With this value: SP--; write(SP, INT)
//
// STILL IMPORTANT TO SEND THE SP SOMEHOW (according to a yt video, 5B00 to 5CCA is reserved for BASIC, so maybe safe?)
//
// IX and IY next: write(SP--, (IX >> 8)); write(SP--, IX&0xFF); ... same with IY

// Stack:
// IY
// IX
// INT
// PC (manual if !.SNA)

alt_u8* generate_routine(REGS regs, enum file_type type, int routine_size) {
	alt_u8* routine = (alt_u8*) malloc(1 * routine_size);
	int i = 0;

	// Load border color into A
	routine[i++] = LD_A_N;
	routine[i++] = regs.border;

	// Load contents of A (border color) to border color addr
	routine[i++] = LD_NN_A;
	routine[i++] = BORDER_COLOR_ADDR_L;
	routine[i++] = BORDER_COLOR_ADDR_H;

	// TECHNICALLY this border color writing could be made with DMA,
	// but this


	// R Register is for RAM refresh, so it might be ok without this...
	// Load R data into A
	routine[i++] = LD_A_N;
	routine[i++] = regs.R;

	// Load contents of A (R data) into R
	routine[i++] = LD_x_A;
	routine[i++] = LD_R_A;

	// Load I data into A
	routine[i++] = LD_A_N;
	routine[i++] = regs.I;

	// Load contents of A (I data) into I
	routine[i++] = LD_x_A;
	routine[i++] = LD_I_A;


	// Load contents of A AUX into A
	routine[i++] = LD_A_N;
	routine[i++] = regs.Al;

	// MISSING FLAGS, BECAUSE CAN'T FIND OPCODE FOR LOADING FLAGS REG (pretty sure there is none)
	// ALSO MISSING WAY OF SETTING IFF2 (not important?)

	// Load HL DE and BC with AUX version values
	routine[i++] = LD_HL_NN;
	routine[i++] = regs.Ll;
	routine[i++] = regs.Hl;

	routine[i++] = LD_DE_NN;
	routine[i++] = regs.El;
	routine[i++] = regs.Dl;

	routine[i++] = LD_BC_NN;
	routine[i++] = regs.Cl;
	routine[i++] = regs.Bl;

	// Exchange AUX value regs with normal
	routine[i++] = EXX;
	routine[i++] = EX_AF;


	// Loads HL contents to HL
	routine[i++] = LD_HL_NN;
	routine[i++] = regs.L;
	routine[i++] = regs.H;

	// Loads DE contents to DE
	routine[i++] = LD_DE_NN;
	routine[i++] = regs.E;
	routine[i++] = regs.D;

	// Loads BC contents to BC
	routine[i++] = LD_BC_NN;
	routine[i++] = regs.C;
	routine[i++] = regs.B;

	// Load contents of A into A
	routine[i++] = LD_A_N;
	routine[i++] = regs.A;

	// Load contents of IY into IY
	routine[i++] = LD_IY1_NN;
	routine[i++] = LD_IY2_NN;
	routine[i++] = regs.IY >> 8;	// already in little endian
	routine[i++] = regs.IY & 0xFF;
	/*routine[i++] = data[SNA_OFFSET_IY];
	routine[i++] = data[SNA_OFFSET_IY+1];*/

	// Load contents of IX into IX
	routine[i++] = LD_IX1_NN;
	routine[i++] = LD_IX2_NN;
	routine[i++] = regs.IX >> 8;
	routine[i++] = regs.IX & 0xFF;

	// Load contents of SP into SP
	routine[i++] = LD_SP_NN;
	routine[i++] = regs.SP >> 8;
	routine[i++] = regs.SP & 0xFF;


	// Set Interrupt mode
	routine[i++] = IM_x;
	alt_u8 interrupt_mode = regs.IM;
	switch (interrupt_mode) {
		case 0:
			routine[i++] = IM_0;
			break;
		case 1:
			routine[i++] = IM_1;
			break;
		case 2:
			routine[i++] = IM_2;
			break;
		default:
			printf("Wrong interrupt byte... defaulting to 1");
			routine[i++] = IM_1;
	}

	if (regs.IFF1) {
		routine[i++] = EI;
	} else {
		routine[i++] = DI;
	}

	if (type == SNA) {
		// Supposedly, right before a .SNA is made, the PC is pushed to stack,
		// so it is set after the instruction RETN
		routine[i++] = RETN1;
		routine[i++] = RETN2;
	} else if (type == Z80) {
		routine[i++] = JP_NN;
		routine[i++] = regs.PC >> 8;
		routine[i++] = regs.PC & 0xFF;
	}

	return routine;
}

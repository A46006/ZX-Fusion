#include "formats.h"
#include "asm_opcodes.h"
#include "mem_addrs.h"

int load_file(FAT_HANDLE hFat, char* filename, int name_len) {
	char* extension = filename + (name_len-4);
	printf("EXTENSION %s\r\n", extension);
	for (int i = 0; i < 4; i++) {
		extension[i] = tolower(extension[i]);
	}
	printf("EXTENSION %s\r\n", extension);
	if (strncmp(extension, ".z80", 4) == 0) {
		return load_z80(hFat, filename);
	}
	if (strncmp(extension, ".sna", 4) == 0) {
		return load_SNA(hFat, filename);
	}
	return -1;
}


/* *******************
 * .SNA format
 * *******************/
REGS generate_regs_SNA(alt_u8* data) {
	alt_u16 sp = conv_data_8_16(data, SNA_OFFSET_SP);

	REGS regs = {
		.R = data[SNA_OFFSET_R],
		.I = data[SNA_OFFSET_I],

		.Al = data[SNA_OFFSET_A_AUX],
		.Fl = data[SNA_OFFSET_F_AUX],
		.Hl = data[SNA_OFFSET_HL_AUX+1], // because little endian
		.Ll = data[SNA_OFFSET_HL_AUX],
		.Dl = data[SNA_OFFSET_DE_AUX+1],
		.El = data[SNA_OFFSET_DE_AUX],
		.Bl = data[SNA_OFFSET_BC_AUX+1],
		.Cl = data[SNA_OFFSET_BC_AUX],

		.A = data[SNA_OFFSET_A],
		.F = data[SNA_OFFSET_F],
		.H = data[SNA_OFFSET_HL+1], // because little endian
		.L = data[SNA_OFFSET_HL],
		.D = data[SNA_OFFSET_DE+1],
		.E = data[SNA_OFFSET_DE],
		.B = data[SNA_OFFSET_BC+1],
		.C = data[SNA_OFFSET_BC],

		//.IY = ((data[SNA_OFFSET_IY] << 8) & 0xFF00) | data[SNA_OFFSET_IY+1],
		.IY = conv_data_8_16(data, SNA_OFFSET_IY),
		.IX = conv_data_8_16(data, SNA_OFFSET_IX),

		.SP = sp,
		.PC = 0, // PC is in the stack

		.IM = data[SNA_OFFSET_INT_MODE],
		.IFF1 = data[SNA_OFFSET_IFF2] & 4,
		.IFF2 = data[SNA_OFFSET_IFF2] & 4,
		.border = data[SNA_OFFSET_BORDER]

	};

	return regs;
}

int load_SNA(FAT_HANDLE hFat, char* filename) {
	FAT_FILE_HANDLE hFile = init_file(hFat, filename);

	if (!hFile) return -1;

	DMA_init();

	int ret = DMA_request(10);

	if (ret != 0) {
		DMA_print_err(ret);
		close_file(hFile);
		return -1;
	}

	int data_offset = SNA_OFFSET_DATA;

	int routine_size = get_routine_size_SNA();

	//REGS regs = write_sna_DMA_mem(hFile, data_offset, 0x4000);



	// Next code based on DE2-115 SD Card reading test code:
	alt_u8 szRead[512];
	int nReadSize=0, nFileSize, nTotalReadSize=0;
	nFileSize = Fat_FileSize(hFile);

	alt_u16 addr = 0x4000;
	REGS regs;
	//alt_u16 ula_addr = 0xFEFE;
	//alt_u8 border_color = 0b00000110;

	bool bSuccess = TRUE;
	bool first_block = TRUE;

	if (nReadSize > sizeof(szRead))
		nReadSize = sizeof(szRead);
	while(bSuccess && nTotalReadSize < nFileSize){
		nReadSize = sizeof(szRead);
		if (nReadSize > (nFileSize - nTotalReadSize))
			nReadSize = (nFileSize - nTotalReadSize);
		//
		if (Fat_FileRead(hFile, szRead, nReadSize)){
			if (first_block) {
				// Save REG values
				regs = generate_regs_SNA(szRead);

				write_buf_mem(addr, szRead, data_offset, nReadSize - data_offset);
				addr += (nReadSize - data_offset);
				first_block = FALSE;
			} else {
				write_buf_mem(addr, szRead, 0, nReadSize);
				addr += nReadSize;

				/*write_io(ula_addr, border_color);
				border_color = (~border_color) & 0b111;*/
			}
			nTotalReadSize += nReadSize;
		}else{
			bSuccess = FALSE;
			close_file(hFile);

			// writing NMI code (just a return)
			addr = NMI_ROUTINE_ADDR;
			write_mem(addr++, RETN1);
			write_mem(addr++, RETN2);

			// stop DMA with NMI on
			DMA_stop_w_interrupt();
			printf("\nFailed to read the file\n");
			return -1;
		}
	} // while

	/*
	// Save data that routine will overwrite
	int data_bk_len = get_routine_size_SNA();
	alt_u8* data_bk = (alt_u8*) malloc(data_bk_len * sizeof(alt_u8*));
	read_buf_mem(NMI_ROUTINE_ADDR, data_bk_len, data_bk);

	// Obtaining PC for later
	alt_u8* pc_buf = (alt_u8*) malloc(2 * sizeof(alt_u8*));
	alt_u16 sp_big = (regs.SP >> 8) | (regs.SP << 8);
	read_buf_mem(sp_big, 2, pc_buf);
	printf("SP: %04x\r\n", sp_big);
	for(int i = 0; i < 2; i++) {
		printf("0x%02x", pc_buf[i]);
	}

	regs.PC = conv_data_8_16(pc_buf, 0); // PC is in the stack
	printf("regs PC: 0x%04x\r\n", regs.PC);
	free(pc_buf)*/

	// Now all the data is loaded, and the routine must be formed with REGS
	enum file_type type = SNA;

	alt_u8* routine = generate_routine(regs, type, routine_size);

	write_buf_mem(NMI_ROUTINE_ADDR, routine, 0, routine_size);

	for(int i = 0; i < routine_size; i++) {
		printf("0x%02x ", routine[i]);
	}

	// Add data of regs with flags to stack
	STACK_ADD stack_addition = generate_AF_stack_addition(regs, type, FALSE);
	alt_u16 sp_value = reverse_16(stack_addition.SP); // making it big endian
	write_buf_mem(sp_value, stack_addition.data, 0, stack_addition.size);
	for(int i = 0; i < stack_addition.size; i++) {
		printf("0x%02x ", stack_addition.data[i]);
	}

	// border addr
	addr = 0x5C48;

	// Quick flash of colors to signify end of loading file
	/*write_io(addr, 0b100);
	usleep(100000);
	write_io(addr, 0b010);
	usleep(100000);
	write_io(addr, 0b001);
	usleep(100000);*/

	// Sets actual border color
	write_io(addr, regs.border & 0b111);

	free(stack_addition.data);
	free(routine);
	close_file(hFile);

	//write_buf_mem(0x4000, data, data_offset, sizeof data);

	// stop DMA with NMI on
	DMA_stop_w_interrupt();

	/*
	// Restore data overwritten by routine as soon as the snapshot's PC is detected in z80 address bus
	// This means the z80 is about to start executing the loaded code
	int wait_res = wait_for_pc(regs.PC, 10000);
	printf("wait res: %d\r\n", wait_res);
	if (!wait_res) {
		DMA_request(10);

		for (int i = 0 ; i < data_bk_len; i++) {
			printf("0x%02x\r\n", data_bk[i]);
		}

		write_buf_mem(NMI_ROUTINE_ADDR, data_bk, 0, data_bk_len);

		free(data_bk);
		DMA_stop(10);
	}*/

	printf("\r\nLOADED");

	return 0;
}

/* *******************
 * .z80 format
 * *******************/
int get_version_z80(alt_u8* data) {
	if (data[Z80_OFFSET_PC] != 0 || data[Z80_OFFSET_PC+1] != 0) return 1;
	if (data[Z80_OFFSET_FLAGS1] == 255) return 1; // because of compatibility, 255 -> v1
	if (data[Z80_OFFSET_H2_LEN] == 23) return 2;
	return 3;
}

bool is_48k(alt_u8* data, int version) {
	if (version == 1) return TRUE;

	alt_u8 hw_mode = data[Z80_OFFSET_HW];
	if (hw_mode == HW_48K /*|| hw_mode == HW_48K_IF1*/) return TRUE;

	return FALSE;
}

bool is_compressed(alt_u8* data) {
	alt_u8 flags1 = data[Z80_OFFSET_FLAGS1];
	if (MASK_FLAGS1_COMPRESSED(flags1)) {
		return TRUE;
	}
	return FALSE;
}

/*DATA_BLOCK_HEADER get_current_block_head(alt_u8* data, int offset, enum data_header_state state) {
	switch (state) {
		case NONE:
			alt_u16 data_block_size = conv_data_8_16(data, offset);
			DATA_BLOCK_HEADER to_ret = {
					.size = (data_block_size << 8) | (data_block_size >> 8), // Reversing endian
					.page = data[offset+2],
					.curr = 0,
					.state = FULL
			};
			return to_ret;
		case SIZE_1:
	}

}*/

alt_u8 get_data_offset(alt_u8* data, int version) {
	if (version == 1) return Z80_OFFSET_DATA_H1;
	if (version == 2) return Z80_OFFSET_DATA_H2_v2;
	if (version == 3) {
		int h2_len = data[Z80_OFFSET_H2_LEN];
		if (h2_len == 54) {
			return Z80_OFFSET_DATA_H2_v3;
		}
		if (h2_len == 55) {
			return Z80_OFFSET_DATA_H2_v3 + 1;
		}
	}
	return -1;
}

REGS generate_regs_z80(alt_u8* data, int version) {
	alt_u16 pc;
	if (version == 1) {
		pc = conv_data_8_16(data, Z80_OFFSET_PC);
	} else {
		pc = conv_data_8_16(data, Z80_OFFSET_PC_H2);
	}

	alt_u8 flags1 = data[Z80_OFFSET_FLAGS1];
	alt_u8 flags2 = data[Z80_OFFSET_FLAGS2];

	REGS regs = {
		.R = (data[Z80_OFFSET_R] & 0x7F) | ((alt_u8)(MASK_FLAGS1_R7(flags1)) << 7),
		.I = data[Z80_OFFSET_I],

		.Al = data[Z80_OFFSET_A_AUX],
		.Fl = data[Z80_OFFSET_F_AUX],
		.Hl = data[Z80_OFFSET_H_AUX],
		.Ll = data[Z80_OFFSET_L_AUX],
		.Dl = data[Z80_OFFSET_D_AUX],
		.El = data[Z80_OFFSET_E_AUX],
		.Bl = data[Z80_OFFSET_B_AUX],
		.Cl = data[Z80_OFFSET_C_AUX],

		.A = data[Z80_OFFSET_A],
		.F = data[Z80_OFFSET_F],
		.H = data[Z80_OFFSET_H],
		.L = data[Z80_OFFSET_L],
		.D = data[Z80_OFFSET_D],
		.E = data[Z80_OFFSET_E],
		.B = data[Z80_OFFSET_B],
		.C = data[Z80_OFFSET_C],

		//.IY = ((data[SNA_OFFSET_IY] << 8) & 0xFF00) | data[SNA_OFFSET_IY+1],
		.IY = conv_data_8_16(data, Z80_OFFSET_IY),
		.IX = conv_data_8_16(data, Z80_OFFSET_IX),

		.SP = conv_data_8_16(data, Z80_OFFSET_SP),
		.PC = pc,

		.IM = MASK_FLAGS2_IM(flags2),
		.IFF1 = data[Z80_OFFSET_INT_FF],
		.IFF2 = data[Z80_OFFSET_IFF2],
		.border = MASK_FLAGS1_BORDER(flags1) >> 1

	};

	return regs;
}

// For keeping track of run-length compression between blocks
enum comp_state state = NONE;
alt_u8 xx; // in case of state = XX, the state of this value needs to be saved
bool zero_detected = FALSE; // for 0 before ED ED, in case it isn't the end tag

alt_u16 load_compressed_data_block_z80(alt_u16 addr, alt_u8* buffer, int data_offset, int nReadSize) {
	//printf("LOADING COMPRESSED DATA BLOCK\r\n");
	alt_u16 addr_return = addr;

	//printf("READ SIZE: %d\r\n", nReadSize);

	// Four-byte code: ED ED xx yy: (byte yy repeats xx times)
	for (int i = data_offset; i < data_offset + nReadSize; i++) {
		//printf("\r\n\t|| current i = %d ||", i);
		alt_u8 data_byte = buffer[i];
		switch (state) {
			case NONE:
				//printf("state 0:");

				// "ED" ED xx yy
				if (data_byte == 0xED) {
					state = ED1;

				// For end marker detection ("00" ED ED 00)
				// If this ends up not being part of the end marker
				// the 0 must be written
				} else if (data_byte == 0) {
					zero_detected = TRUE;
					state = ZERO;

				// Normal data
				} else {
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);
				}
				break;

			case ZERO:
				// Might be end tag
				if (data_byte == 0xED) {
					state = ED1;
				} else {
					// false alarm, that 0 was data
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0);
					write_mem(addr_return++, 0);
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);
					zero_detected = FALSE;
					state = NONE;
				}
				break;
			case ED1:
				//printf("\r\nstate ED1\r\n");

				// ED "ED" xx yy
				if (data_byte == 0xED) {
					state = ED2;

				// Turns out it was just 1 0xED
				} else {

					// If a 0 was before the ED, it was just data
					if (zero_detected) {
						//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0);
						write_mem(addr_return++, 0);
						zero_detected = FALSE;
					}
					// If only one ED happened after all, then write that ED and the current byte
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0xED);
					write_mem(addr_return++, 0xED);
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);
					state = NONE;
				}
				break;
			case ED2:
				//printf("\r\nstate ED2\r\n");

				// ED ED "xx" yy
				xx = data_byte;

				// if xx = 0, then ED ED 00 => 00 ED ED 00
				if (xx == 0) {
					printf("\r\nEOF tag\r\n");
					state = NONE; // Should it be this?
					break;
				}

				// if 00 ED ED xx yy, then 00 should have been written
				if (zero_detected) {
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0);
					write_mem(addr_return++, 0);
					zero_detected = FALSE;
				}

				state = XX;
				break;
			case XX:

				// ED ED xx "yy"
				// yy = data_byte
				// so write data_byte xx amount of times
				for (int j = 0; j < xx; j++) {
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);

				}
				state = NONE;
				break;
		}
	}

	return addr_return;
}

int load_z80(FAT_HANDLE hFat, char* filename) {
	FAT_FILE_HANDLE hFile = init_file(hFat, filename);

	if (!hFile) {
		printf("FILE NOT FOUND\r\n");
		return -1;
	}

	int ret = DMA_request(10);

	if (ret != 0) {
		DMA_print_err(ret);
		close_file(hFile);
		return -1;
	}

	int routine_size = get_routine_size_z80();



	// Next code based on DE2-115 SD Card reading test code:
	alt_u8 szRead[256];
	int nReadSize=0, nFileSize, nTotalReadSize=0;
	nFileSize = Fat_FileSize(hFile);

	alt_u16 addr = 0x4000;
	REGS regs;

	//////////// for files with v2 or v3 ////////////
	bool is_v1_data_format = TRUE;


	// Array to keep block header, in case it spans more than one data block
	// the data that was obtained from the previous block stays in this array
	alt_u8 block_header[DATA_BLOCK_HEADER_SIZE] = {0};

	// size of the array, to keep track of how much data has already been added to it
	int block_header_obtained_size = 0;

	// keeps track of data block size that is left to process
	alt_u16 data_block_size = 0;

	////////////////////
	bool bSuccess = TRUE;
	bool first_block = TRUE;

	// For data
	int data_offset;
	bool compressed;

	if (nReadSize > sizeof(szRead))
		nReadSize = sizeof(szRead);
	while(bSuccess && nTotalReadSize < nFileSize){
		nReadSize = sizeof(szRead);
		if (nReadSize > (nFileSize - nTotalReadSize))
			nReadSize = (nFileSize - nTotalReadSize);
		//
		if (Fat_FileRead(hFile, szRead, nReadSize)){
			if (first_block) {

				// Getting version of the file
				int version = get_version_z80(szRead);
				is_v1_data_format = version == 1;

				// Making sure it is for the 48k
				if (!is_48k(szRead, version)) {
					printf("%s is not for 48k\r\n", filename);
					DMA_stop(10);
					close_file(hFile);
					return -1;
				}

				// Get start of data dependent on version
				data_offset = get_data_offset(szRead, version);
				if (data_offset == -1) {
					printf("Problem getting data offset (new version of .z80 file?)\r\n");
					DMA_stop(10);
					close_file(hFile);
					return -1;
				}

				// Save REG values
				regs = generate_regs_z80(szRead, version);

				// Check if data is compressed or not
				compressed = is_compressed(szRead);


				// saving header of data block for files with version 2 or 3
				// Since this is the first SD card data block, it is guaranteed to have one of these (if v2 or v3)
				if (!is_v1_data_format) {
					for (int i = 0; i < DATA_BLOCK_HEADER_SIZE; i++) {
						block_header[i] = szRead[data_offset+i];
					}
					data_offset += DATA_BLOCK_HEADER_SIZE;
					// reverse endian
					data_block_size = reverse_16(conv_data_8_16(block_header, 0));
					block_header_obtained_size = DATA_BLOCK_HEADER_SIZE;
				}


				if (!compressed) {
					int read_size = nReadSize - data_offset;
					int remaining_block_size = read_size;

					if (!is_v1_data_format) {
						if (data_block_size < read_size)
							read_size = data_block_size;
					}

					// ONLY write to RAM if the block describes page 8
					if (is_v1_data_format || block_header[2] == 8) {
						write_buf_mem(addr, szRead, data_offset, read_size);
						addr += read_size;
					}
					data_offset += read_size;
					data_block_size -= read_size;
					// In case this SD card data block has no more to read
					if (remaining_block_size != read_size) {
						block_header_obtained_size = 0; // New block header being obtained
						remaining_block_size -= read_size; // obtaining remaining block size

						// Calculating how much of the header I can obtain now
						int header_to_obtain = DATA_BLOCK_HEADER_SIZE;
						if (header_to_obtain > remaining_block_size) {
							header_to_obtain = remaining_block_size;
						}

						// Adding new block header data
						for(int i = 0; i < header_to_obtain; i++) {
							block_header[i] = szRead[data_offset+i];
						}
						block_header_obtained_size = header_to_obtain;
						data_offset += header_to_obtain; // move data offset in case there is still more
						read_size = nReadSize - data_offset; // updating read size in case there is more data
						if (block_header_obtained_size == DATA_BLOCK_HEADER_SIZE) {
							data_block_size = reverse_16(conv_data_8_16(block_header, 0));

							if (read_size > 0) { // if there is still more data
								if (block_header[2] == 8) {
									write_buf_mem(addr, szRead, data_offset, read_size);
									addr += read_size;
								}
								data_block_size -= read_size; // updating data block size (what is left)
							}
						}
						printf("remaining data block size: %d\r\n", data_block_size);
					}

				} else {
					addr = load_compressed_data_block_z80(addr, szRead, data_offset, nReadSize - data_offset);
				}
				first_block = FALSE;

			} else {
				if (!compressed) {
					write_buf_mem(addr, szRead, 0, nReadSize);
					addr += nReadSize;
				} else {
					addr = load_compressed_data_block_z80(addr, szRead, 0, nReadSize);
				}
				/*write_io(ula_addr, border_color);
				border_color = (~border_color) & 0b111;*/
			}

			nTotalReadSize += nReadSize;
		}else{
			bSuccess = FALSE;
			printf("\nFailed to read the file\n");
		}
	} // while

	printf("\r\nLeft the loop\r\n");
	printf("ADDRESS: %x\r\n", addr);

	// Now all the data is loaded, and the routine must be formed with REGS
	enum file_type type = Z80;

	printf("REGS:\r\n");
	printf("|PC: %04x\t\tSP: %04x\r\n", regs.PC, regs.SP);
	printf("|AF: %04x\t\tAF': %04x\r\n", ((regs.F << 8) & 0xFF00) | regs.A, ((regs.Fl << 8) & 0xFF00) | regs.Al);
	printf("|BC: %04x\t\tBC': %04x\r\n", ((regs.C << 8) & 0xFF00) | regs.B, ((regs.Cl << 8) & 0xFF00) | regs.Bl);
	printf("|DE: %04x\t\tDE': %04x\r\n", ((regs.E << 8) & 0xFF00) | regs.D, ((regs.El << 8) & 0xFF00) | regs.Dl);
	printf("|HL: %04x\t\tHL': %04x\r\n", ((regs.L << 8) & 0xFF00) | regs.H, ((regs.Ll << 8) & 0xFF00) | regs.Hl);
	printf("|IX: %04x\t\tIY: %04x\r\n", regs.IX, regs.IY);
	printf("|I: %02x\t\tR: %02x\r\n", regs.I, regs.R);

	// Save data that routine will overwrite
	int data_bk_len = get_routine_size_z80();
	alt_u8* data_bk = (alt_u8*) malloc(data_bk_len * sizeof(alt_u8*));
	read_buf_mem(NMI_ROUTINE_ADDR, data_bk_len, data_bk);


	alt_u8* routine = generate_routine(regs, type, routine_size);

	write_buf_mem(NMI_ROUTINE_ADDR, routine, 0, routine_size);

	for(int i = 0; i < routine_size; i++) {
		printf("0x%02x ", routine[i]);
	}

	printf("\r\n------------\r\n");

	//STACK_ADD stack_addition = generate_AF_stack_addition(regs, type, TRUE);
	STACK_ADD stack_addition = generate_AF_stack_addition(regs, type, TRUE);
	alt_u16 sp_value = reverse_16(stack_addition.SP); // making it big endian
	write_buf_mem(sp_value, stack_addition.data, 0, stack_addition.size);
	for(int i = 0; i < stack_addition.size; i++) {
		printf("0x%02x ", stack_addition.data[i]);
	}

	// border addr
	addr = 0x5C48;

	// Quick flash of colors to signify end of loading file
	/*write_io(addr, 0b100);
	usleep(100000);
	write_io(addr, 0b010);
	usleep(100000);
	write_io(addr, 0b001);
	usleep(100000);*/

	// Sets actual border color
	write_io(addr, routine[1] & 0b111);

	state = NONE; // redundant?
	free(stack_addition.data);
	free(routine);
	close_file(hFile);

	// stop DMA with NMI on
	DMA_stop_w_interrupt();

	// Restore data overwritten by routine as soon as the snapshot's PC is detected in z80 address bus
	// This means the z80 is about to start executing the loaded code
	int wait_res = wait_for_pc(regs.PC, 10000);
	if (!wait_res) {
		// PATCH OVER CORRECT DATA
		DMA_request(10);

		for (int i = 0 ; i < data_bk_len; i++) {
			printf("0x%02x\r\n", data_bk[i]);
		}

		write_buf_mem(NMI_ROUTINE_ADDR, data_bk, 0, data_bk_len);

		free(data_bk);
		DMA_stop(10);
	}

	printf("\r\nLOADED\r\n");

	return 0;

}

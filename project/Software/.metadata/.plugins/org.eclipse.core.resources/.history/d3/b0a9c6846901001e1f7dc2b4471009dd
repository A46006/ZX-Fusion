#include "formats.h"
#include "asm_opcodes.h"
#include "mem_addrs.h"

/* *******************
 * .SNA format
 * *******************/
REGS generate_regs_SNA(alt_u8* data) {
	REGS regs = {
		.R = data[SNA_OFFSET_R],
		.I = data[SNA_OFFSET_I],

		.Al = data[SNA_OFFSET_A_AUX],
		.Fl = data[SNA_OFFSET_F_AUX],
		.Hl = data[SNA_OFFSET_HL_AUX+1], // because little endian
		.Ll = data[SNA_OFFSET_HL_AUX],
		.Dl = data[SNA_OFFSET_DE_AUX+1],
		.El = data[SNA_OFFSET_DE_AUX],
		.Bl = data[SNA_OFFSET_BC_AUX+1],
		.Cl = data[SNA_OFFSET_BC_AUX],

		.A = data[SNA_OFFSET_A],
		.F = data[SNA_OFFSET_F],
		.H = data[SNA_OFFSET_HL+1], // because little endian
		.L = data[SNA_OFFSET_HL],
		.D = data[SNA_OFFSET_DE+1],
		.E = data[SNA_OFFSET_DE],
		.B = data[SNA_OFFSET_BC+1],
		.C = data[SNA_OFFSET_BC],

		//.IY = ((data[SNA_OFFSET_IY] << 8) & 0xFF00) | data[SNA_OFFSET_IY+1],
		.IY = conv_data_8_16(data, SNA_OFFSET_IY),
		.IX = conv_data_8_16(data, SNA_OFFSET_IX),

		.SP = conv_data_8_16(data, SNA_OFFSET_SP),
		.PC = 0, // PC is in the stack

		.IM = data[SNA_OFFSET_INT_MODE],
		.IFF1 = data[SNA_OFFSET_IFF2] & 4,
		.IFF2 = data[SNA_OFFSET_IFF2] & 4,
		.border = data[SNA_OFFSET_BORDER]

	};

	return regs;
}

int load_SNA(char* filename) {
	FAT_HANDLE hFat = init_SD();

	FAT_FILE_HANDLE hFile = init_file(hFat, filename);

	if (!hFile) return -1;

	DMA_init();

	int ret = DMA_request(10);

	if (ret != 0) {
		DMA_print_err(ret);
		close_file(hFile);
		close_SD(hFat);
		return -1;
	}

	int data_offset = SNA_OFFSET_DATA;

	int routine_size = get_routine_size_SNA();

	//REGS regs = write_sna_DMA_mem(hFile, data_offset, 0x4000);



	// Next code based on DE2-115 SD Card reading test code:
	alt_u8 szRead[512];
	int nReadSize=0, nFileSize, nTotalReadSize=0;
	nFileSize = Fat_FileSize(hFile);

	alt_u16 addr = 0x4000;
	REGS regs;
	//alt_u16 ula_addr = 0xFEFE;
	//alt_u8 border_color = 0b00000110;

	bool bSuccess = TRUE;
	bool first_block = TRUE;

	if (nReadSize > sizeof(szRead))
		nReadSize = sizeof(szRead);
	while(bSuccess && nTotalReadSize < nFileSize){
		nReadSize = sizeof(szRead);
		if (nReadSize > (nFileSize - nTotalReadSize))
			nReadSize = (nFileSize - nTotalReadSize);
		//
		if (Fat_FileRead(hFile, szRead, nReadSize)){
			if (first_block) {
				// Save REG values
				regs = generate_regs_SNA(szRead);

				write_buf_mem(addr, szRead, data_offset, nReadSize - data_offset);
				addr += (nReadSize - data_offset);
				first_block = FALSE;
			} else {
				write_buf_mem(addr, szRead, 0, nReadSize);
				addr += nReadSize;

				/*write_io(ula_addr, border_color);
				border_color = (~border_color) & 0b111;*/
			}

			/*int i;
			int l = 0;
			for(i=0;i<16;i++){
				//printf("%c", szRead[i]);
				printf("0x%x ", szRead[i]);
				if (l++ == 16) {
					printf("\r\n");
					l = 0;
				};
			}*/
			nTotalReadSize += nReadSize;
		}else{
			bSuccess = FALSE;
			printf("\nFaied to read the file\"\n");
		}
	} // while




	// Now all the data is loaded, and the routine must be formed with REGS
	enum file_type type = SNA;

	alt_u8* routine = generate_routine(regs, type, routine_size);

	write_buf_mem(0xFF58, routine, 0, routine_size);

	for(int i = 0; i < routine_size; i++) {
		printf("0x%02x ", routine[i]);
	}

	// border addr
	addr = 0xFEFE;

	// Quick flash of colors to signify end of loading file
	/*write_io(addr, 0b100);
	usleep(100000);
	write_io(addr, 0b010);
	usleep(100000);
	write_io(addr, 0b001);
	usleep(100000);*/

	// Sets actual border color
	write_io(addr, routine[1] & 0b111);

	free(routine);
	close_file(hFile);
	close_SD(hFat);

	//write_buf_mem(0x4000, data, data_offset, sizeof data);

	// stop DMA with NMI on
	DMA_stop_w_interrupt();

	printf("\r\nLOADED");

	return 0;
}

/* *******************
 * .z80 format
 * *******************/
int get_version_z80(alt_u8* data) {
	if (data[Z80_OFFSET_PC] != 0 || data[Z80_OFFSET_PC+1] != 0) return 1;
	if (data[Z80_OFFSET_H2_LEN] == 23) return 2;
	return 3;
}

bool is_48k(alt_u8* data, int version) {
	if (version == 1) return TRUE;

	alt_u8 hw_mode = data[Z80_OFFSET_HW];
	if (hw_mode == HW_48K) return TRUE;

	return FALSE;
}

bool is_compressed(alt_u8* data) {
	alt_u8 flags1 = data[Z80_OFFSET_FLAGS1];
	if (MASK_FLAGS1_COMPRESSED(flags1)) {
		return TRUE;
	}
	return FALSE;
}

alt_u8 get_data_offset(alt_u8* data, int version) {
	if (version == 1) return Z80_OFFSET_DATA_H1;
	if (version == 2) return Z80_OFFSET_DATA_H2_v2;
	if (version == 3) {
		int h2_len = data[Z80_OFFSET_H2_LEN];
		if (h2_len == 54) {
			return Z80_OFFSET_DATA_H2_v3;
		}
		if (h2_len == 55) {
			return Z80_OFFSET_DATA_H2_v3 + 1;
		}
	}
	return -1;
}

REGS generate_regs_z80(alt_u8* data, int version) {
	alt_u16 pc;
	if (version == 1) {
		pc = conv_data_8_16(data, Z80_OFFSET_PC);
	} else {
		pc = conv_data_8_16(data, Z80_OFFSET_PC_H2);
	}

	alt_u8 flags1 = data[Z80_OFFSET_FLAGS1];
	alt_u8 flags2 = data[Z80_OFFSET_FLAGS2];

	REGS regs = {
		.R = (data[Z80_OFFSET_R] & 0x7F) | ((alt_u8)(MASK_FLAGS1_R7(flags1)) << 7),
		.I = data[Z80_OFFSET_I],

		.Al = data[Z80_OFFSET_A_AUX],
		.Fl = data[Z80_OFFSET_F_AUX],
		.Hl = data[Z80_OFFSET_H_AUX],
		.Ll = data[Z80_OFFSET_L_AUX],
		.Dl = data[Z80_OFFSET_D_AUX],
		.El = data[Z80_OFFSET_E_AUX],
		.Bl = data[Z80_OFFSET_B_AUX],
		.Cl = data[Z80_OFFSET_C_AUX],

		.A = data[Z80_OFFSET_A],
		.F = data[Z80_OFFSET_F],
		.H = data[Z80_OFFSET_H],
		.L = data[Z80_OFFSET_L],
		.D = data[Z80_OFFSET_D],
		.E = data[Z80_OFFSET_E],
		.B = data[Z80_OFFSET_B],
		.C = data[Z80_OFFSET_C],

		//.IY = ((data[SNA_OFFSET_IY] << 8) & 0xFF00) | data[SNA_OFFSET_IY+1],
		.IY = conv_data_8_16(data, Z80_OFFSET_IY),
		.IX = conv_data_8_16(data, Z80_OFFSET_IX),

		.SP = conv_data_8_16(data, Z80_OFFSET_SP),
		.PC = pc,

		.IM = MASK_FLAGS2_IM(flags2),
		.IFF1 = data[Z80_OFFSET_INT_FF],
		.IFF2 = data[Z80_OFFSET_IFF2],
		.border = MASK_FLAGS1_BORDER(flags1) >> 1

	};

	return regs;
}

// For keeping track of run-length compression between blocks
enum comp_state state = NONE;
alt_u8 xx; // in case of state = XX, the state of this value needs to be saved
bool zero_detected = FALSE; // for 0 before ED ED, in case it isn't the end tag

alt_u16 load_compressed_data_block_z80(alt_u16 addr, alt_u8* buffer, int data_offset, int nReadSize) {
	//printf("LOADING COMPRESSED DATA BLOCK\r\n");
	alt_u16 addr_return = addr;

	//printf("READ SIZE: %d\r\n", nReadSize);

	// Four-byte code: ED ED xx yy: (byte yy repeats xx times)
	for (int i = data_offset; i < data_offset + nReadSize; i++) {
		//printf("\r\n\t|| current i = %d ||", i);
		alt_u8 data_byte = buffer[i];
		switch (state) {
			case NONE:
				//printf("state 0:");

				// "ED" ED xx yy
				if (data_byte == 0xED) {
					state = ED1;

				// For end marker detection ("00" ED ED 00)
				// If this ends up not being part of the end marker
				// the 0 must be written
				} else if (data_byte == 0) {
					zero_detected = TRUE;
					state = ZERO;

				// Normal data
				} else {
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);
				}
				break;

			case ZERO:
				// Might be end tag
				if (data_byte == 0xED) {
					state = ED1;
				} else {
					// false alarm, that 0 was data
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0);
					write_mem(addr_return++, 0);
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);
					zero_detected = FALSE;
					state = NONE;
				}
				break;
			case ED1:
				//printf("\r\nstate ED1\r\n");

				// ED "ED" xx yy
				if (data_byte == 0xED) {
					state = ED2;

				// Turns out it was just 1 0xED
				} else {

					// If a 0 was before the ED, it was just data
					if (zero_detected) {
						//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0);
						write_mem(addr_return++, 0);
						zero_detected = FALSE;
					}
					// If only one ED happened after all, then write that ED and the current byte
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0xED);
					write_mem(addr_return++, 0xED);
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);
					state = NONE;
				}
				break;
			case ED2:
				//printf("\r\nstate ED2\r\n");

				// ED ED "xx" yy
				xx = data_byte;

				// if xx = 0, then ED ED 00 => 00 ED ED 00
				if (xx == 0) {
					printf("\r\nEOF tag\r\n");
					state = NONE; // Should it be this?
					break;
				}

				// if 00 ED ED xx yy, then 00 should have been written
				if (zero_detected) {
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, 0);
					write_mem(addr_return++, 0);
					zero_detected = FALSE;
				}

				state = XX;
				break;
			case XX:

				// ED ED xx "yy"
				// yy = data_byte
				// so write data_byte xx amount of times
				for (int j = 0; j < xx; j++) {
					//printf("(%x): 0x%x; ", addr_return - 0x5B00, data_byte);
					write_mem(addr_return++, data_byte);

				}
				state = NONE;
				break;
		}
	}

	return addr_return;
}

int load_z80(char* filename) {
	FAT_HANDLE hFat = init_SD();

	FAT_FILE_HANDLE hFile = init_file(hFat, filename);

	if (!hFile) return -1;

	DMA_init();

	int ret = DMA_request(10);

	if (ret != 0) {
		DMA_print_err(ret);
		close_file(hFile);
		close_SD(hFat);
		return -1;
	}

	int routine_size = get_routine_size_z80();



	// Next code based on DE2-115 SD Card reading test code:
	alt_u8 szRead[256];
	int nReadSize=0, nFileSize, nTotalReadSize=0;
	nFileSize = Fat_FileSize(hFile);

	alt_u16 addr = 0x4000;
	REGS regs;
	//alt_u16 ula_addr = 0xFEFE;
	//alt_u8 border_color = 0b00000110;

	bool bSuccess = TRUE;
	bool first_block = TRUE;

	// For data
	int data_offset;
	bool compressed;

	if (nReadSize > sizeof(szRead))
		nReadSize = sizeof(szRead);
	while(bSuccess && nTotalReadSize < nFileSize){
		nReadSize = sizeof(szRead);
		if (nReadSize > (nFileSize - nTotalReadSize))
			nReadSize = (nFileSize - nTotalReadSize);
		//
		if (Fat_FileRead(hFile, szRead, nReadSize)){
			if (first_block) {

				// Getting version of the file
				int version = get_version_z80(szRead);

				// Making sure it is for the 48k
				if (!is_48k(szRead, version)) {
					printf("%s is not for 48k\r\n", filename);
					DMA_stop(10);
					close_file(hFile);
					close_SD(hFat);
					return -1;
				}

				// Get start of data dependent on version
				data_offset = get_data_offset(szRead, version);
				if (data_offset == -1) {
					printf("Problem getting data offset (new version of .z80 file?)\r\n");
					DMA_stop(10);
					close_file(hFile);
					close_SD(hFat);
					return -1;
				}

				// Save REG values
				regs = generate_regs_z80(szRead, version);

				// Check if data is compressed or not
				compressed = is_compressed(szRead);

				if (!compressed) {
					write_buf_mem(addr, szRead, data_offset, nReadSize - data_offset);
					addr += (nReadSize - data_offset);
				} else {
					addr = load_compressed_data_block_z80(addr, szRead, data_offset, nReadSize - data_offset);
				}
				first_block = FALSE;
				//printf("STATE: %d\r\n", state);
				//printf("ZERO DETECTED: %d\r\n", zero_detected);
				//printf("\r\nFIRST TIME\r\n");
			} else {
				if (!compressed) {
					write_buf_mem(addr, szRead, 0, nReadSize);
					addr += nReadSize;
				} else {
					addr = load_compressed_data_block_z80(addr, szRead, 0, nReadSize);
				}
				/*write_io(ula_addr, border_color);
				border_color = (~border_color) & 0b111;*/
			}

			nTotalReadSize += nReadSize;
		}else{
			bSuccess = FALSE;
			printf("\nFaied to read the file\"\n");
		}
	} // while

	printf("\r\nLeft the loop\r\n");
	printf("ADDRESS: %x\r\n", addr);

	// Now all the data is loaded, and the routine must be formed with REGS
	enum file_type type = Z80;

	printf("REGS:\r\n");
	printf("PC: %02x", regs.PC);
	printf("AF: %02x", ((regs.F << 8) & 0xFF00) | regs.A);
	printf("BC: %02x", ((regs.C << 8) & 0xFF00) | regs.B);
	printf("DE: %02x", ((regs.E << 8) & 0xFF00) | regs.D);
	printf("HL: %02x", ((regs.L << 8) & 0xFF00) | regs.H);
	printf("IX: %02x", regs.IX);
	printf("I: %x", regs.I);



	alt_u8* routine = generate_routine(regs, type, routine_size);

	write_buf_mem(0xFF58, routine, 0, routine_size);

	for(int i = 0; i < routine_size; i++) {
		printf("0x%02x ", routine[i]);
	}

	// border addr
	addr = 0xFEFE;

	// Quick flash of colors to signify end of loading file
	/*write_io(addr, 0b100);
	usleep(100000);
	write_io(addr, 0b010);
	usleep(100000);
	write_io(addr, 0b001);
	usleep(100000);*/

	// Sets actual border color
	write_io(addr, routine[1] & 0b111);

	state = NONE; // redundant?
	free(routine);
	close_file(hFile);
	close_SD(hFat);

	//write_buf_mem(0x4000, data, data_offset, sizeof data);

	// stop DMA with NMI on
	DMA_stop_w_interrupt();

	printf("\r\nLOADED\r\n");

	return 0;

}
